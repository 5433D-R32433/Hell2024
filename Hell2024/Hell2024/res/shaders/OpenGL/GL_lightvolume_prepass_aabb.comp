#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) uniform sampler2DArray lightVolumeShadowMapArray;

struct LightVolumeData {
	float aabbMinX;
	float aabbMinY;
	float aabbMinZ;
	float padding;
	float aabbMaxX;
	float aabbMaxY;
	float aabbMaxZ;
	float padding2;
};

layout(std430, binding = 19) buffer Buffer {
    LightVolumeData lightVolumeData[];
};

uniform int lightIndex;

void main() {

	const int SHADOW_MAP_SIZE = 512;
			
	float minX = 0xFFFFFFFF;
	float minY = 0xFFFFFFFF;
	float minZ = 0xFFFFFFFF;
	float maxX = 0;
	float maxY = 0;
	float maxZ = 0;

	for (int x = 0; x < SHADOW_MAP_SIZE; x++) {
		for (int y = 0; y < SHADOW_MAP_SIZE; y++) {	
			for (int f = 0; f < 6; f++) {				
				vec3 worldPos = texelFetch(lightVolumeShadowMapArray, ivec3(x, y, f), 0).rgb;				
				minX = min(minX, worldPos.x); 
				minY = min(minY, worldPos.y); 
				minZ = min(minZ, worldPos.z); 
				maxX = max(maxX, worldPos.x); 
				maxY = max(maxY, worldPos.y); 
				maxZ = max(maxZ, worldPos.z); 
			}	
		}
	}
	lightVolumeData[lightIndex].aabbMinX = minX - 0.01;
	lightVolumeData[lightIndex].aabbMinY = minY - 0.01;
	lightVolumeData[lightIndex].aabbMinZ = minZ - 0.01;
	lightVolumeData[lightIndex].aabbMaxX = maxX + 0.01;
	lightVolumeData[lightIndex].aabbMaxY = maxY + 0.01;
	lightVolumeData[lightIndex].aabbMaxZ = maxZ + 0.01;

}